---
{"dg-publish":true,"permalink":"/5-digital-garden/published/papers/paper-review/a-5-58-n-w-crystal-oscillator-using-pulsed-driver-for-real-time-clocks/","tags":["ULP","crystal_oscillator","pulse_injection","RTC","body_biasing"],"created":"2026-01-06T16:26:30.511+09:00"}
---

--- 
- Motivation & Thought: 
	- 첨언/특이한 점/추가로 찾아볼 점:
		- 첨언) 수식적인 분석이 많이 적혀있음. 특히 초기 디자인 포인트는 수식으로 어느 정도 결정하여, 설계 시작점을 고정시키고 나머지 포인트에 대해서 시뮬레이션을 돌려 결정한 모습이 참고할만함.
		- <mark style="background: #FFB86CA6;">XTAL에서 timing 정보를 받기 위한 body-biased inverter Front end + DLL + PG 구조를 참조하기 좋다.</mark>
			- 아날로그적인 테크닉이 엄청 많이 쓰임
		- 특이한 점 1) Power를 극도로 낮추기 위해서 여러모로 duty-cycling technique가 들어갔다. => Analog biasing cell들을 항상 키는 것이 아니라 cap.에 의도한 voltage를 저장해두고자 하여 Area 소모가 극도로 커졌음 (물론 180nm 공정을 쓴 것도 있음). 
			- => IC를 stacking해서 시스템을 구현하던 해당 그룹의 접근을 고려한다면 area는 주요 constaint가 아니라서 이런 식의 접근을 많이 한 듯 함.
		- 특이한 점 2) Multiple VDD domain에서 동작시켜 power 소모를 낮췄음. 이때 on-chip으로 multiple VDD domain을 생성하기 위하여 SCN (Switched cap. network)을 사용하였음. 하지만, start-up을 위한 clock은 또 on-chip으로 넣지 않고 외부에서 넣어주었음... 디자인의 편의를 위해서 그랬다는데 개인적으로는 둘 다 넣거나 둘 다 넣지 않는 쪽이 일관된 접근이라 생각함. 아마 SCN을 기존 work과 바꿔서 구현하여 테스트해보고 싶은 부분이 있었던게 아닐까 추측.
		- 특이한 점 3) <mark style="background: #FFB86CA6;">DLL을 사용하고 pre-defined phase를 선택하는 꼴로 동작 시킴. => peak보다 느린, 딱 맞는, 빠른 pulse들을 MUX를 통해서 만들 수 있는데, pre-defined phase를 골라서 이용함.</mark> => 추가로, 측정 결과에서 pulse selection으로 인한 성능 degradation이 그리 크지 않다는 것도 나옴.
		- Q) 해당 페이퍼를 읽고 이런 방식으로 ULP하게 XO를 동작시킬 수 있다면, HFXO를 always-on, low power mode operation 시켜서 system RTC으로 사용하면 안되는 것일까? 라는 의문이 생김.
			- A) technique를 적용하였음에도 불구하고 5.58nW per 32.768kHz가 소요되었으니 (power breakdown이 없어서 섯부른 추측일 수는 있지만) 만약 32MHz대라면 ~5uW는 소모하였을 것. => RTC로 쓰기에는 소모가 너무 크다.
		- Level shifter에서 Vth가 서로 다른 MOSFET을 어떻게 이용하여 자체적으로 delay를 넣어줌으로써 contention path를 방지하는지에 대한 부분 有
		- Driver의 on-resistance로 인한 non-ideality에 대한 분석 有
			- 짧은 시간이라 Inductor current는 변화하지 않고, cap.에 전부 충전된다는 가정 하에서 에너지 변화를 분석하여 amplitude에 대해 이야기함.
- Summary: 
	- <mark style="background: #FFB86CA6;">하고자 한 바 (1문장으로)</mark>
		- 그냥 amplifier (inverter as a driver)를 사용하여 XTAL resonator를 구동하는 경우 생기는 큰 power 소모를 줄이기 위해 1) pre-amplifier를 XTAL resonator driver 앞에 붙임 2) 항상 driving 하는게 아니라 pulsing을 통해 driving 함 (driving도 duty cycling 시켰다고 볼 수 있지) 의 2가지 아이디어를 이용하여 새로운 XTAL driver를 제안함.
	- <mark style="background: #FFB86CA6;">왜 쓰여진 논문인가.</mark>
		- Target Application/문제 상황: 
			- Scenario
				- 1) Sensor node가 hub/base station랑 통신을 하는 경우, hub는 power 소모가 주요 제한조건이 아니기에 hub 측에서 guardbanding을 해주면 충분함. => sensor node 자체는 무척 낮은 power consumption을 달성
				- 2) Sensor node 끼리 통신한다고 가정할 경우, communication timing random mismatch를 해결하기 위하여 guardband를 요구하고 이는 긴 wake-up time => energy 소모로 이어짐.
					- 해당 시나리오에서는 x38의 power 소모.
				- ![Pasted image 20260106170239.png|center](/img/user/0.%20TOOLS/00.%20Attechments/Pasted%20image%2020260106170239.png)
			- 따라서 XTAL을 accurate한 RTC로 이용하여야 이러한 문제를 해결할 수 있음. 이런 경우 RTC의 power 소모가 전체 시스템의 power 소모 bottlenecl이 됨.
			- 해당 문제를 해결하기 위하여 freq. stability는 유지하며 power consumption을 낮추려고 함. 
				- Issue 1) Amplitude control이 없는 경우 발생하는 문제: signal이 clipping 됨 => reliability issue of XTAL이 생길 수 있음 => Series R을 달아서 XTAL의 양단 amplitude를 줄임. => inverter driver의 static current 소모, uncontrolled gain, (과한 amplitude로 인한 XTAL reliability issue를 막기 위한) series resistor의 power 소모가 문제
				- Issue 2) 그 와중에 amplitude가 너무 줄어들면 driver strength를 유지하기 위하여 driver size가 커지고, 또 power 소모로 이어짐. => 해결을 위해 feedback으로 amplitude control 하기를 도입하면 1) driver가 여전히 static bias current 소모 2) topology의 current mirror가 power 소모 3) monitoring을 위한 amp.가 power 소모 4) amplitude control을 위한 current mirror loop에서의 device matcing 필요 의 문제가 남음.
	- <mark style="background: #FFB86CA6;">어떻게 해결했지.</mark>
		- Main Idea/제안점: 
			- 1) Pre-amplifier concept: Driver 단을 two-step으로 나누고 각기 다른 VDD를 줌. Vgs를 유지시켜 on-resistance를 낮추며 동시에 작은 oscillation amplitude로 인한 약해진 driver strength 문제도 해결함.
				- 하지만 남아있는 issue는 1) pre-amp를 op-amp로 만들면 BW가 충분해야 하므로 power 소모가 >10nW level임 2) 만약 driver가 너무 강해지면 ampltude가 다시금 clipping 되면서 series resistance를 요구함.
				- ![Pasted image 20260106172259.png|center](/img/user/0.%20TOOLS/00.%20Attechments/Pasted%20image%2020260106172259.png)
			- 2) Driver도 pulse로 동작시킴.
				- timing은 DLL + pre-defined pulse selection으로 구현.
				- ![Pasted image 20260106172845.png|center](/img/user/0.%20TOOLS/00.%20Attechments/Pasted%20image%2020260106172845.png)
	- <mark style="background: #FFB86CA6;">해결 결과는.</mark>
		- 좋아진 점/수치적으로:
			- key-parameters: power, Allan deviation, temperature stability (w/ temp. range). supply voltage dependence
				- Area: 0.3mm2
				- Freq.: 32.768kHz
				- Power: 5.58nW
				- Temperature stability: -20°C ~ 80°C, -4.56~133.3ppm drift
				- VDD dependence: 30.3ppm/V
				- Alland dev. <0.1n at 1000s avg window
		- Trade-off: 

Circuit:
- ![Pasted image 20260107133942.png](/img/user/0.%20TOOLS/00.%20Attechments/Pasted%20image%2020260107133942.png)
	- DLL을 구동하기 위하여 작은 크기의 OSC_IN을 sensing하여야 함. => 정확히 half VDD를 기준으로 inverter가 동작해야하기에 bias generator가 필요함.
	- 그런데 body bias generator 자체가 ~nW를 소모하기에 on-chip 60pF cap.을 이용하여 body biasing voltage를 저장하여 이용. (2 cycle per 32 cycle의 duty를 지님)
	- Double-stacked inverter는 자체로 power를 줄이기 위해 이용.

- ![Pasted image 20260107134732.png](/img/user/0.%20TOOLS/00.%20Attechments/Pasted%20image%2020260107134732.png)
	- Level shifter / level converter
- ![Pasted image 20260107134805.png](/img/user/0.%20TOOLS/00.%20Attechments/Pasted%20image%2020260107134805.png)
	- Chip die: SCN의 capacitor가 면적의 대부분을 차지한다. 

---
